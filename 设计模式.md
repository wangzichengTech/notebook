# 设计模式

## OOP七大原则

- 开闭原则：对扩展开放，对修改关闭（比如有两个功能块，我现在想新增第三个功能块（独立扩展），新增的功能块不会影响另外两个功能块工作）

- 里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立（子类可以扩展父类的功能，但不要改变父类原有的功能，也就是不要重写父类方法）
- 依赖导致原则：[要面向接口编程，不要面向实现编程](https://blog.csdn.net/u013400743/article/details/51252003)
- 单一职责原则：控制类的粒度大小，将对象解耦，提高其内聚性（一个方法干一件事，也就是我们所说的原子性）
- 接口隔离原则：要为各个类建立它们需要的专用接口
- 迪米特法则：只与你的直接朋友交谈，不跟“陌生人”说话
- 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系（里氏替换）来实现

## 单例模式

**概念：**确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。（隐藏含义就是要求构造方法是private，并且拥有当前类的静态成员变量，再提供一个静态方法向外界提供当前类的实例）

序列号生成器和web页面计数器等等都可以使用单例模式，访问IO或者数据库资源的时候，我们可以使用单例模式来减少资源的消耗。

### 饿汉式单例

一开始就把实例加载进来

```java
package com.kuang;

import java.lang.reflect.Constructor;

//饿汉式单例
public class Hungry {
//    可能会浪费空间
    private Hungry(){

    }
    private final static Hungry HUNGRY = new Hungry();
    public static Hungry getInstance(){
        return HUNGRY;
    }
}

```

### 懒汉式单例

懒加载，使用时才加载，详细见代码注释

- 双重检测锁模式：保证多线程情况下单例也安全
- volatile关键字：增加volatile关键字告诉jvm是易变的，不要优化策略而进行指令重排
- 我们可以利用反射操作来破坏单例模式，具体见主函数代码

```java
package com.kuang;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

//懒汉式单例
//道高一尺，魔高一丈
public class LazyMan {
    private static boolean flag = false;
    private LazyMan(){
        synchronized (LazyMan.class){
            if (flag == false){
                flag = true;
            }else {
                throw new RuntimeException("不要试图使用反射破坏异常");
            }
        }
//        System.out.println(Thread.currentThread().getName()+"ok");
    }
//    避免指令重排，保证变量的内存可见性
    private volatile static LazyMan lazyMan;
//双重检测锁模式的懒汉式单例  DCL懒汉式
    public static LazyMan getInstance(){
        if (lazyMan==null){
//            使用同步块减少同步的范围
            synchronized (LazyMan.class){
                if (lazyMan==null){
                    lazyMan = new LazyMan();//不是一个原子性操作
                    /*
                    *1.分配内存空间
                    *2.执行构造方法，初始化对象
                    *3.把这个对象指向这个空间
                    * 123
                    * 132 A
                    *     B
                    */
                }
            }
        }
        return lazyMan;//此时lazyMan还没有完成构造
    }
    //反射
    public static void main(String[] args) throws Exception {
//        LazyMan instance = LazyMan.getInstance();
        Field flag = LazyMan.class.getDeclaredField("flag");
        flag.setAccessible(true);
        Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);
//        无视私有构造器
        declaredConstructor.setAccessible(true);
        LazyMan instance1 = declaredConstructor.newInstance();
        flag.set(instance1,false);
        LazyMan instance2 = declaredConstructor.newInstance();
//        反射可以破坏这种单例模式
        System.out.println(instance1);
        System.out.println(instance2);
    }
//    多线程并发
//public static void main(String[] args) {
//    for (int i = 0; i <10 ; i++) {
//        new Thread(()->{
//            LazyMan.getInstance();
//        }).start();
//    }
//}
}

```

### 静态内部类单例

好处：首先不会再外部类被加载时就加载，所以具备懒汉特质，其次多线程安全（具体待补充）

```java
package com.kuang;
//静态内部类
public class Holder {
    private Holder(){

    }
    public static Holder getInstance(){
        return InnerClass.HOLDER;
    }
    public static class InnerClass{
        private static final Holder HOLDER = new Holder();
    }
}

```

### 枚举单例

由于反射可以改变类的构成元素，包括访问修饰符的限制，详见懒汉式单例中的代码

我们可以利用枚举，发现反射破解枚举不成功

- 普通的反编译会欺骗开发者，说enum枚举是无参构造

通过无参构造反射，显示没有找到构造方法：

![image-20220125210019399](C:\Users\10130\AppData\Roaming\Typora\typora-user-images\image-20220125210019399.png)

![image-20220125204634238](C:\Users\10130\AppData\Roaming\Typora\typora-user-images\image-20220125204634238.png)

- 实际enum为有参构造

![image-20220125205146373](C:\Users\10130\AppData\Roaming\Typora\typora-user-images\image-20220125205146373.png)

![image-20220125205222229](C:\Users\10130\AppData\Roaming\Typora\typora-user-images\image-20220125205222229.png)

idea查看该Java文件，发现了构造函数参数

![image-20220125205325199](C:\Users\10130\AppData\Roaming\Typora\typora-user-images\image-20220125205325199.png)

- 通过反射破解枚举会发现抛出异常

之后通过反射有参构造得到

![image-20220125205558292](C:\Users\10130\AppData\Roaming\Typora\typora-user-images\image-20220125205558292.png)

反射确实不能破坏枚举的单例

```java
package com.kuang;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

//enum是一个什么？本身也是一个Class类
public enum EnumSingle {
    INSTANCE;
    public EnumSingle getInstance(){
        return INSTANCE;
    }

}
class Test{
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        EnumSingle instance1 = EnumSingle.INSTANCE;
        Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class);
        declaredConstructor.setAccessible(true);
        EnumSingle instance2 = declaredConstructor.newInstance();
        System.out.println(instance1);
        System.out.println(instance2);
    }
}
```

